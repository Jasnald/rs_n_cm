# -*- coding: utf-8 -*-
"""
plane_data_utils.py
What it does:
This module provides utility functions for saving, loading, 
and extracting data related to fitted planes and stepwise measurement data. 
It supports JSON serialization of polynomial and Chebyshev fit results, 
extraction of original and fitted points, and loading of step-segmented data 
for further analysis or visualization.

Example of use:
    from plane_data_utils import save_plane_data_json, load_plane_data_from_json, extract_points_from_plane_data
    # Save plane fit results to JSON
    save_plane_data_json(side, points, params, degree, method_name, eq_str, base_directory, calculate_z_func, norm_params)
    # Load plane data from JSON
    data = load_plane_data_from_json('Side1__1_standard.json')
    # Extract arrays from loaded data
    X, Y, Z_orig, Z_fit, residuals = extract_points_from_plane_data(data)
"""
import json
import numpy as np
import logging
from typing import Dict, Any, Tuple, Optional, List
import os

def save_plane_data_json(
    side: str,
    points: List[Tuple[float, float, float]],
    params: np.ndarray,
    degree: int,
    method_name: str,
    eq_str: str,
    base_directory: str,
    calculate_z_func,
    norm_params: Optional[Dict[str, float]] = None
) -> None:
    """
    save_plane_data_json / (function)
    What it does:
    Saves the details of a plane fit (coefficients, equation, original and fitted points) to a JSON file. Supports both polynomial and Chebyshev methods, using the provided calculation function and normalization parameters if needed.
    """
    plane_data_dir = os.path.join(base_directory)
    if not os.path.exists(plane_data_dir):
        os.makedirs(plane_data_dir)

    file_name = f"{side}__{degree}_{method_name.lower()}.json"
    file_path = os.path.join(plane_data_dir, file_name)

    point_info_list = []
    for x, y, z in points:
        if method_name.lower() == "chebyshev" and norm_params is not None:
            z_fit = calculate_z_func(params, x, y, degree, norm_params)
        else:
            z_fit = calculate_z_func(params, x, y, degree)
        point_info_list.append({
            "x": x,
            "y": y,
            "z_original": z,
            "z_fitted": float(z_fit),
            "residual": float(z - z_fit)
        })

    data_to_save = {
        "side": side,
        "degree": degree,
        "method_name": method_name,
        "equation": eq_str,
        "parameters": params.tolist(),
        "points": point_info_list
    }

    if norm_params is not None:
        data_to_save["normalization_parameters"] = norm_params

    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(data_to_save, f, indent=2, ensure_ascii=False)
    # logging.info(f"Arquivo JSON salvo: {file_path}")

def load_plane_data_from_json(file_path: str) -> Optional[Dict[str, Any]]:
    """
    load_plane_data_from_json / (function)
    What it does:
    Loads plane fit data from a JSON file generated by the fitting scripts. Returns a dictionary with all plane details or None on error.
    Args:
        file_path: Path to the JSON file.
    Returns:
        Dictionary with plane data (points, equation, etc.) or None if loading fails.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data
    except (IOError, json.JSONDecodeError) as e:
        logging.error(f"Erro ao ler arquivo {file_path}: {e}")
        return None


def extract_points_from_plane_data(
    plane_data: Dict[str, Any]
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    extract_points_from_plane_data / (function)
    What it does:
    Extracts original and fitted points from plane fit data, returning arrays for X, Y, original Z, fitted Z, and residuals.
    Args:
        plane_data: Dictionary with plane data (must contain a 'points' list).
    Returns:
        Tuple of NumPy arrays: (X, Y, Z_orig, Z_fit, residuals)
    """
    if not plane_data or 'points' not in plane_data:
        return (np.array([]), np.array([]), np.array([]), np.array([]), np.array([]))

    X, Y, Z_orig, Z_fit, residuals = [], [], [], [], []

    for point in plane_data['points']:
        X.append(point['x'])
        Y.append(point['y'])
        Z_orig.append(point['z_original'])
        Z_fit.append(point['z_fitted'])
        residuals.append(point['residual'])

    return (
        np.array(X, dtype=float),
        np.array(Y, dtype=float),
        np.array(Z_orig, dtype=float),
        np.array(Z_fit, dtype=float),
        np.array(residuals, dtype=float)
    )

def load_steps_data_from_json(file_path: str) -> Optional[Dict[str, Any]]:
    """
    load_steps_data_from_json / (function)
    What it does:
    Loads step-segmented measurement data from a JSON file in the new format. Returns a dictionary with all step data or None on error.
    Args:
        file_path: Path to the JSON file.
    Returns:
        Dictionary with step data or None if loading fails.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data
    except (IOError, json.JSONDecodeError) as e:
        logging.error(f"Erro ao ler arquivo de steps {file_path}: {e}")
        return None


def extract_points_from_steps_data(steps_data: Dict[str, Any]) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    extract_points_from_steps_data / (function)
    What it does:
    Extracts all (X, Y, Z) coordinates from step-segmented data in the new JSON format, returning NumPy arrays for each coordinate.
    Args:
        steps_data: Dictionary with step data (must contain a 'steps' list).
    Returns:
        Tuple of NumPy arrays: (X, Y, Z)
    """
    if not steps_data or 'steps' not in steps_data:
        return np.array([]), np.array([]), np.array([])

    X, Y, Z = [], [], []
    
    # Percorre cada step
    for step in steps_data['steps']:
        if 'points' in step:
            # Percorre cada ponto dentro deste step
            for point in step['points']:
                X.append(point.get('x', 0))
                Y.append(point.get('y', 0))
                Z.append(point.get('z', 0))
    
    return np.array(X, dtype=float), np.array(Y, dtype=float), np.array(Z, dtype=float)